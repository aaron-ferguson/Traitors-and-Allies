<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Among Us - In-Person Game Manager</title>
    <!-- Supabase Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            color: #ff3838;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
        }

        .subtitle {
            color: #a0a0a0;
            font-size: 1.1rem;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .card h2 {
            margin-bottom: 20px;
            color: #5eb3f6;
            font-size: 1.5rem;
        }

        .card h3 {
            margin: 20px 0 15px 0;
            color: #5eb3f6;
            font-size: 1.2rem;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .input-row .input-group {
            flex: 1;
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #ddd;
            font-weight: 500;
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            font-size: 1rem;
            transition: all 0.3s;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #5eb3f6;
            background: rgba(255, 255, 255, 0.1);
        }

        select option {
            background: #16213e;
            color: #fff;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        button {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #5eb3f6 0%, #4a9ddb 100%);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(94, 179, 246, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff3838 0%, #d32f2f 100%);
            color: #fff;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 56, 56, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
            color: #fff;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
        }

        /* Disabled button styling */
        button:disabled,
        button[disabled] {
            opacity: 0.5;
            cursor: not-allowed !important;
            background: #cccccc !important;
            transform: none !important;
            box-shadow: none !important;
        }

        button:disabled:hover,
        button[disabled]:hover {
            transform: none !important;
            box-shadow: none !important;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: #fff;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            color: #fff;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(108, 117, 125, 0.4);
        }

        .btn-block {
            width: 100%;
            margin-top: 10px;
        }

        .hidden {
            display: none !important;
        }

        /* Room/Task Selection */
        .room-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .room-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .room-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .task-list {
            list-style: none;
            margin-left: 30px;
        }

        .task-item {
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 15px;
        }

        .task-item input[type="checkbox"] {
            margin-top: 3px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Collapsible Section */
        .collapsible {
            background: rgba(94, 179, 246, 0.2);
            cursor: pointer;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            border: 2px solid rgba(94, 179, 246, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapsible:hover {
            background: rgba(94, 179, 246, 0.3);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .collapsible-content.active {
            max-height: 2000px;
            transition: max-height 0.5s ease-in;
        }

        /* Game Stats */
        .game-stats {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            flex: 1;
            min-width: 150px;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: #5eb3f6;
        }

        .stat-label {
            color: #a0a0a0;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        /* Player Badges */
        .player-badge {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 1.1rem;
            border: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .player-ready {
            border-color: #4caf50;
        }

        .ready-indicator {
            background: #4caf50;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
        }

        /* Role Display */
        .role-display {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .role-hidden {
            font-size: 2rem;
            letter-spacing: 5px;
            color: #666;
            user-select: none;
        }

        .role-revealed {
            font-size: 2rem;
            font-weight: 700;
        }

        .role-imposter {
            color: #ff3838;
        }

        .role-crewmate {
            color: #5eb3f6;
        }

        /* Task Timer */
        .task-timer {
            text-align: center;
            padding: 40px;
            background: rgba(94, 179, 246, 0.2);
            border-radius: 15px;
            margin: 20px 0;
        }

        .timer-display {
            font-size: 4rem;
            font-weight: 700;
            color: #5eb3f6;
            margin: 20px 0;
        }

        .timer-task-name {
            font-size: 1.5rem;
            color: #ddd;
            margin-bottom: 15px;
        }

        /* QR Code Display */
        .qr-display {
            text-align: center;
            padding: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
        }

        .qr-placeholder {
            width: 200px;
            height: 200px;
            background: white;
            margin: 20px auto;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
        }

        /* Meeting Overlay */
        .meeting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: flashRed 0.5s infinite;
        }

        @keyframes flashRed {
            0%, 100% {
                background: rgba(255, 0, 0, 0.95);
            }
            50% {
                background: rgba(200, 0, 0, 0.95);
            }
        }

        .meeting-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .meeting-content h2 {
            font-size: 3rem;
            color: #fff;
            margin-bottom: 20px;
            animation: shake 0.5s infinite;
        }

        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }
            25% {
                transform: translateX(-10px);
            }
            75% {
                transform: translateX(10px);
            }
        }

        /* Voting Interface */
        .vote-option {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .vote-option:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #5eb3f6;
        }

        .vote-option.selected {
            background: rgba(94, 179, 246, 0.3);
            border-color: #5eb3f6;
        }

        .vote-results {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .vote-bar {
            background: rgba(94, 179, 246, 0.3);
            height: 30px;
            border-radius: 5px;
            position: relative;
            margin-top: 10px;
        }

        .vote-bar-fill {
            background: #5eb3f6;
            height: 100%;
            border-radius: 5px;
            transition: width 0.5s;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            padding: 20px;
        }

        .modal-content {
            background: #1a1a2e;
            border-radius: 15px;
            padding: 30px;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            border: 2px solid rgba(94, 179, 246, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
        }

        /* Victory/Defeat Screen */
        .end-screen {
            text-align: center;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .victory {
            background: rgba(76, 175, 80, 0.2);
            border: 3px solid #4caf50;
        }

        .defeat {
            background: rgba(255, 56, 56, 0.2);
            border: 3px solid #ff3838;
        }

        .end-screen h2 {
            font-size: 3rem;
            margin-bottom: 20px;
        }

        .victory h2 {
            color: #4caf50;
        }

        .defeat h2 {
            color: #ff3838;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }

            .input-row {
                flex-direction: column;
            }

            .timer-display {
                font-size: 3rem;
            }

            .meeting-content h2 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Among Us IRL</h1>
            <p class="subtitle">Minigames and betrayal in your own backyard!</p>
        </header>

        <!-- MAIN MENU -->
        <div id="main-menu">
            <div class="card" style="text-align: center; max-width: 500px; margin: 0 auto;">
                <button class="btn-primary btn-block" onclick="showCreateGame()" style="margin-bottom: 15px; font-size: 1.2rem; padding: 20px;">
                    Create New Game
                </button>

                <button class="btn-secondary btn-block" onclick="showJoinGame()" style="margin-bottom: 15px; font-size: 1.2rem; padding: 20px;">
                    Join Existing Game
                </button>

                <button class="btn-secondary btn-block" onclick="showInstructions()" style="font-size: 1.2rem; padding: 20px;">
                    Game Instructions
                </button>

                <!-- Join Game Input (hidden by default) -->
                <div id="join-game-section" class="hidden" style="margin-top: 30px; padding-top: 30px; border-top: 2px solid rgba(255,255,255,0.1);">
                    <h3>Enter Room Code</h3>
                    <input type="text" id="menu-room-code-input" placeholder="Enter 4-letter code"
                           style="width: 100%; padding: 15px; font-size: 1.2rem; text-align: center; text-transform: uppercase; letter-spacing: 5px; margin-bottom: 15px;"
                           maxlength="4">
                    <div style="display: flex; gap: 10px;">
                        <button class="btn-success" onclick="joinGameFromMenu()" style="flex: 1;">Join Game</button>
                        <button class="btn-secondary" onclick="hideJoinGame()" style="flex: 1;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- STAGE 1: GAME SETUP -->
        <div id="setup-phase">
            <div class="card">
                <h2>Game Setup</h2>

                <!-- General Setup -->
                <h3>General Settings</h3>
                <div class="input-row">
                    <div class="input-group">
                        <label for="min-players">Minimum Players (recommended ‚â•4):</label>
                        <input type="number" id="min-players" min="3" max="15" value="4">
                    </div>
                    <div class="input-group">
                        <label for="max-players">Maximum Players (recommended ‚â§15):</label>
                        <input type="number" id="max-players" min="3" max="15" value="10">
                    </div>
                </div>

                <div class="input-group">
                    <label for="tasks-per-player">Tasks per Player:</label>
                    <input type="number" id="tasks-per-player" min="1" max="10" value="4">
                </div>

                <!-- Room & Task Selection -->
                <h3>Rooms & Tasks</h3>
                <div class="collapsible" onclick="toggleCollapsible(this)">
                    <span>Select Rooms and Tasks in Play</span>
                    <span>‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div id="rooms-tasks-container"></div>
                </div>

                <!-- Unique Tasks Configuration -->
                <h3>Unique Tasks</h3>
                <div class="input-group">
                    <label>
                        <input type="radio" name="unique-mode" value="none" checked> No unique tasks
                    </label>
                    <label>
                        <input type="radio" name="unique-mode" value="random"> Randomly assign
                        <input type="number" id="unique-count" min="1" max="3" value="2" style="width: 60px; display: inline-block; padding: 5px;"> unique task(s)
                    </label>
                    <label>
                        <input type="radio" name="unique-mode" value="manual"> Manually select unique tasks (flag them above)
                    </label>
                </div>

                <!-- Imposter Setup -->
                <h3>Imposter Settings</h3>
                <div class="input-group">
                    <label for="imposter-count">Number of Imposters:</label>
                    <input type="number" id="imposter-count" min="1" max="3" value="1">
                    <small style="color: #a0a0a0; display: block; margin-top: 5px;">
                        Recommended: 4-5 players = 1, 6-8 players = 2, 9-15 players = 3
                    </small>
                </div>
                <div class="input-row">
                    <div class="input-group">
                        <label for="elimination-cooldown">Elimination Cooldown (seconds):</label>
                        <input type="number" id="elimination-cooldown" min="10" max="120" value="30">
                    </div>
                    <div class="input-group">
                        <label for="cooldown-reduction">Cooldown Reduction After Meeting (seconds):</label>
                        <input type="number" id="cooldown-reduction" min="0" max="30" value="5">
                    </div>
                </div>

                <!-- Meeting Setup -->
                <h3>Meeting Settings</h3>
                <div class="input-group">
                    <label for="meeting-room">Meeting Location:</label>
                    <select id="meeting-room">
                        <option value="">Select a room...</option>
                    </select>
                </div>
                <div class="input-row">
                    <div class="input-group">
                        <label for="meeting-limit">Emergency Meetings Allowed:</label>
                        <input type="number" id="meeting-limit" min="0" max="10" value="1">
                        <small style="color: #a0a0a0; display: block; margin-top: 5px;">Default: 1 per player</small>
                    </div>
                    <div class="input-group">
                        <label for="meeting-timer">Meeting Timer (seconds):</label>
                        <input type="number" id="meeting-timer" min="30" max="300" value="60">
                    </div>
                </div>

                <!-- Additional Rules -->
                <h3>Additional Rules</h3>
                <div class="input-group">
                    <label for="additional-rules">Additional Instructions (out-of-bounds areas, special rules, etc.):</label>
                    <textarea id="additional-rules" placeholder="Example: The basement and second floor are out of bounds. Stay on the main floor only."></textarea>
                </div>

                <button class="btn-primary btn-block" onclick="(async () => await createGame())()">Create Game & Enter Waiting Room</button>
            </div>
        </div>

        <!-- STAGE 2: WAITING ROOM -->
        <div id="waiting-room" class="hidden">
            <div class="card">
                <h2>Waiting Room</h2>

                <!-- Room Code & QR -->
                <div style="background: rgba(94, 179, 246, 0.2); border: 3px solid rgba(94, 179, 246, 0.5); border-radius: 15px; padding: 25px; margin-bottom: 25px; text-align: center;">
                    <p style="color: #a0a0a0; margin-bottom: 10px;">Share this code or scan the QR:</p>
                    <div style="display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 15px;">
                        <div id="room-code" style="font-size: 3rem; font-weight: 700; letter-spacing: 8px; color: #5eb3f6;">ABCD</div>
                        <button onclick="copyGameURL()" class="btn-primary" style="padding: 15px 25px;">
                            üìã Copy URL
                        </button>
                    </div>
                    <div class="qr-placeholder" style="width: 200px; height: 200px; margin: 10px auto; background: white; border-radius: 10px; padding: 10px; display: flex; align-items: center; justify-content: center;">
                        <img id="qr-code-image" src="" alt="QR Code" style="width: 100%; height: 100%;">
                    </div>
                    <p id="copy-feedback" style="color: #4caf50; margin-top: 10px; font-weight: 600; opacity: 0; transition: opacity 0.3s;">URL copied to clipboard!</p>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="btn-primary" onclick="showInstructions()" style="flex: 1;">
                        üìñ Game Instructions
                    </button>
                    <button class="btn-warning" onclick="editSettings()" style="flex: 1;" id="edit-settings-btn">
                        ‚öôÔ∏è Edit Settings
                    </button>
                </div>

                <!-- Game Stats -->
                <div class="game-stats">
                    <div class="stat-box">
                        <div class="stat-number"><span id="ready-count">0</span>/<span id="min-players-display">4</span></div>
                        <div class="stat-label">Ready / Minimum</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-number"><span id="joined-count">0</span>/<span id="max-players-display">10</span></div>
                        <div class="stat-label">Joined / Maximum</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-number" id="imposter-count-display">1</div>
                        <div class="stat-label">Imposters</div>
                    </div>
                </div>

                <!-- Join Section -->
                <div class="card" style="background: rgba(255, 255, 255, 0.05);">
                    <h3>Join the Game</h3>

                    <!-- Form to join game (shown when not joined) -->
                    <div id="join-form">
                        <p style="color: #a0a0a0; margin-bottom: 15px;">Enter your name to join the lobby</p>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="player-name-input" placeholder="Your name" style="flex: 1;">
                            <button class="btn-primary" onclick="joinGame()">Join</button>
                        </div>
                        <p id="room-full-message" class="hidden" style="color: #ff3838; margin-top: 10px; font-weight: 600;">
                            Room is full! Maximum players reached.
                        </p>
                    </div>

                    <!-- Already joined view (shown after joining) -->
                    <div id="already-joined" class="hidden">
                        <p style="color: #4caf50; margin-bottom: 15px;">‚úì You have joined as <strong id="my-player-name"></strong></p>
                        <button class="btn-primary" onclick="editMyName()" style="width: 100%;">‚úèÔ∏è Edit My Name</button>
                        <button class="btn-warning" onclick="leaveGame()" style="width: 100%; margin-top: 10px;">Leave Game</button>
                    </div>
                </div>

                <!-- Players List -->
                <div class="card" style="background: rgba(255, 255, 255, 0.05);">
                    <h3>Players Ready (<span id="ready-list-count">0</span>)</h3>
                    <div id="lobby-players"></div>
                </div>

                <!-- Host Controls -->
                <button class="btn-success btn-block" onclick="startGame()" id="start-game-btn" disabled>
                    Start Game (Waiting for minimum players to be ready)
                </button>
            </div>
        </div>

        <!-- STAGE 3: GAMEPLAY -->
        <div id="game-phase" class="hidden">
            <!-- Role Display -->
            <div class="card">
                <h2>Your Role</h2>
                <div class="role-display">
                    <div id="role-hidden" class="role-hidden">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</div>
                    <div id="role-revealed" class="hidden">
                        <span id="role-text"></span>
                    </div>
                    <button class="btn-primary" onclick="toggleRole()" style="margin-top: 15px;" id="toggle-role-btn">
                        Reveal Role
                    </button>
                </div>
            </div>

            <!-- Task List -->
            <div class="card" id="task-list-card">
                <h2>Your Tasks (<span id="completed-tasks-count">0</span>/<span id="total-tasks-count">0</span>)</h2>
                <div id="player-tasks"></div>
            </div>

            <!-- Emergency Meeting Button -->
            <div class="card">
                <button class="btn-danger btn-block" onclick="callMeeting()" style="font-size: 1.5rem; padding: 20px;">
                    CALL MEETING
                </button>
                <p style="text-align: center; color: #a0a0a0; margin-top: 10px;">
                    Emergency meetings remaining: <span id="meetings-remaining">1</span>
                </p>
            </div>
        </div>

        <!-- STAGE 4: MEETING -->
        <div id="meeting-phase" class="hidden">
            <!-- Report Body Selection -->
            <div class="card hidden" id="report-selection">
                <h2>Report Body</h2>
                <p style="color: #a0a0a0; margin-bottom: 15px;">Select eliminated player(s):</p>
                <div id="eliminated-players-list"></div>
                <button class="btn-primary btn-block" onclick="confirmReport()">Confirm Report</button>
            </div>

            <!-- Discussion Phase -->
            <div class="card hidden" id="discussion-phase">
                <h2>Discussion Phase</h2>
                <p style="text-align: center; color: #a0a0a0; margin-bottom: 20px;">
                    Discuss who you think the imposter is...
                </p>
                <div style="text-align: center;">
                    <div class="timer-display" id="discussion-timer">60</div>
                    <button class="btn-success btn-block" onclick="startVoting()" id="start-voting-btn">
                        Start Voting
                    </button>
                </div>
            </div>

            <!-- Voting Phase -->
            <div class="card hidden" id="voting-phase">
                <h2>Vote to Eject</h2>
                <p style="text-align: center; color: #a0a0a0; margin-bottom: 15px;">
                    Time remaining: <span id="vote-timer">60</span>s
                </p>
                <div id="vote-options"></div>
                <button class="btn-primary btn-block" onclick="submitVote()" id="submit-vote-btn" disabled>
                    Submit Vote
                </button>
            </div>

            <!-- Vote Results -->
            <div class="card hidden" id="vote-results">
                <h2>Vote Results</h2>
                <div id="results-display"></div>
                <div style="margin-top: 20px; padding: 20px; background: rgba(255, 255, 255, 0.05); border-radius: 10px; text-align: center;">
                    <h3 id="ejected-player-text"></h3>
                </div>
                <button class="btn-success btn-block" onclick="resumeGame()">
                    Resume Game
                </button>
            </div>
        </div>

        <!-- STAGE 5: GAME END -->
        <div id="game-end" class="hidden">
            <!-- Victory/Defeat Screen -->
            <div id="victory-screen" class="end-screen hidden">
                <h2>VICTORY</h2>
                <p style="font-size: 1.5rem; margin: 20px 0;">Your team won!</p>
                <p style="color: #a0a0a0;">Return to the meeting location: <span id="meeting-location-victory">Living Room</span></p>
            </div>

            <div id="defeat-screen" class="end-screen hidden">
                <h2>DEFEAT</h2>
                <p style="font-size: 1.5rem; margin: 20px 0;">Your team was defeated!</p>
                <p style="color: #a0a0a0;">Return to the meeting location: <span id="meeting-location-defeat">Living Room</span></p>
            </div>

            <!-- Game Summary -->
            <div class="card">
                <h2>Game Results</h2>
                <div style="text-align: center; margin-bottom: 30px;">
                    <h3 id="winning-team" style="font-size: 2rem;"></h3>
                </div>

                <h3>All Players</h3>
                <div id="game-summary"></div>

                <!-- Host Controls (only visible to host) -->
                <div id="host-game-controls" class="hidden" style="margin-top: 30px;">
                    <button class="btn-primary btn-block" onclick="newGameSameSettings()">
                        New Game (Same Settings)
                    </button>
                    <button class="btn-secondary btn-block" onclick="newGameNewSettings()">
                        New Game (Change Settings)
                    </button>
                    <button class="btn-secondary btn-block" onclick="endSession()">
                        End Session
                    </button>
                </div>

                <!-- Join Next Game Button (shown when player declines immediate join) -->
                <div id="join-next-game-section" class="hidden" style="margin-top: 30px; text-align: center;">
                    <button class="btn-primary btn-block" onclick="acceptNewGameInvitation()">
                        Join Next Game
                    </button>
                </div>
            </div>
        </div>

        <!-- New Game Invitation Modal (outside game-end so it can show independently) -->
        <div id="new-game-invitation" class="modal hidden">
            <div class="modal-content" style="max-width: 400px;">
                <h2>New Game Starting</h2>
                <p style="color: #a0a0a0; margin: 20px 0;">The host is starting a new game. Would you like to join?</p>
                <button class="btn-primary btn-block" onclick="acceptNewGameInvitation()" style="margin-bottom: 10px;">
                    Join New Game
                </button>
                <button class="btn-secondary btn-block" onclick="declineNewGameInvitation('later')" style="margin-bottom: 10px;">
                    Not Yet
                </button>
                <button class="btn-secondary btn-block" onclick="declineNewGameInvitation('no')">
                    No Thanks
                </button>
            </div>
        </div>

        <!-- Name Confirmation Modal (outside game-end so it can show independently) -->
        <div id="name-confirmation-modal" class="modal hidden">
            <div class="modal-content" style="max-width: 400px;">
                <h2>Confirm Your Name</h2>
                <p style="color: #a0a0a0; margin: 20px 0;">Your previous name: <strong id="previous-name-display"></strong></p>
                <div id="name-edit-section" class="hidden" style="margin-bottom: 20px;">
                    <input type="text" id="name-edit-input" placeholder="Enter your name"
                           style="width: 100%; padding: 12px; font-size: 1rem; margin-bottom: 10px;">
                </div>
                <button class="btn-primary btn-block" onclick="confirmPlayerName()" id="confirm-name-btn" style="margin-bottom: 10px;">
                    Confirm Name
                </button>
                <button class="btn-secondary btn-block" onclick="editPlayerName()" id="edit-name-btn" style="margin-bottom: 10px;">
                    Edit Name
                </button>
                <button class="btn-secondary btn-block" onclick="leaveGame()">
                    Leave Game
                </button>
            </div>
        </div>

        <!-- Task Timer Modal -->
        <div id="task-timer-modal" class="modal hidden">
            <div class="modal-content">
                <div class="task-timer">
                    <h2 id="timer-task-name" class="timer-task-name"></h2>
                    <div class="timer-display" id="task-timer-display">30</div>
                    <p style="color: #a0a0a0;">Complete this task...</p>
                </div>
            </div>
        </div>

        <!-- Eliminated QR Modal -->
        <div id="eliminated-modal" class="modal hidden">
            <div class="modal-content">
                <div class="qr-display">
                    <h2 style="color: #ff3838; margin-bottom: 20px;">You Have Been Eliminated</h2>
                    <p style="color: #a0a0a0; margin-bottom: 20px;">
                        Show this QR code when your body is discovered
                    </p>
                    <div class="qr-placeholder" style="width: 200px; height: 200px; margin: 10px auto; background: white; border-radius: 10px; padding: 10px; display: flex; align-items: center; justify-content: center;">
                        <img id="eliminated-qr-code" src="" alt="Eliminated QR Code" style="width: 100%; height: 100%;">
                    </div>
                    <button class="btn-primary" onclick="closeEliminatedModal()" style="margin-top: 20px;">
                        Continue Doing Tasks
                    </button>
                </div>
            </div>
        </div>

        <!-- Instructions Modal -->
        <div id="instructions-modal" class="modal hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Game Instructions</h2>
                    <button class="modal-close" onclick="closeInstructions()">√ó</button>
                </div>

                <h3>How to Win</h3>
                <h4 style="color: #5eb3f6; margin-top: 15px;">Crewmates Win If:</h4>
                <ul style="margin-left: 20px; margin-bottom: 15px; line-height: 1.8;">
                    <li>All tasks are completed (including tasks of eliminated players)</li>
                    <li>All imposters are eliminated</li>
                </ul>

                <h4 style="color: #ff3838;">Imposters Win If:</h4>
                <ul style="margin-left: 20px; margin-bottom: 20px; line-height: 1.8;">
                    <li>Number of imposters equals remaining crewmates (forcing tied votes)</li>
                </ul>

                <h3>Important Rules</h3>
                <ul style="margin-left: 20px; margin-bottom: 20px; line-height: 1.8;">
                    <li><strong>Crewmates must walk.</strong> Imposters can move at any speed.</li>
                    <li><strong>Stay safe.</strong> Don't do a task if it would put you in danger. Report concerns to the host.</li>
                    <li><strong>Eliminated players can still complete tasks</strong> - your contributions still count toward crew victory!</li>
                </ul>

                <h3>Additional Rules</h3>
                <p id="additional-rules-display" style="color: #a0a0a0; margin-bottom: 20px;"></p>

                <button class="btn-primary btn-block" onclick="closeInstructions()">Got It!</button>
            </div>
        </div>

        <!-- Meeting Alert Overlay -->
        <div id="meeting-overlay" class="meeting-overlay hidden">
            <div class="meeting-content">
                <h2>MEETING CALLED</h2>
                <p style="font-size: 1.5rem; margin-bottom: 30px;">Return to: <span id="meeting-location-alert">Meeting Room</span></p>

                <!-- Meeting type selection - only shown to the player who called the meeting -->
                <div id="meeting-caller-controls" class="hidden" style="margin-bottom: 20px;">
                    <p style="color: #666; margin-bottom: 15px;">What type of meeting is this?</p>
                    <button class="btn-secondary btn-block" onclick="selectMeetingType('report')" style="margin-bottom: 10px;">
                        Report
                    </button>
                    <button class="btn-primary btn-block" onclick="selectMeetingType('emergency')">
                        Emergency Meeting
                    </button>
                </div>

                <button class="btn-primary" style="font-size: 1.2rem; padding: 15px 40px;" onclick="acknowledgeMeeting()">
                    I'm Here
                </button>
            </div>
        </div>
    </div>

    <script>
        // ==================== SUPABASE CONFIGURATION ====================
        // TODO: Replace these with your Supabase project credentials
        // Get these from: https://supabase.com/dashboard/project/YOUR_PROJECT/settings/api
        const SUPABASE_URL = 'https://slmmwedexgtpxoyxfkey.supabase.co';  // e.g., 'https://xxxxx.supabase.co'
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNsbW13ZWRleGd0cHhveXhma2V5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4OTA2NDksImV4cCI6MjA3ODQ2NjY0OX0.TDy1r0V3Sex-Zcldh29q_yvGeYi04o_KJ8haDQdOXUg';  // Your anon/public key

        // Initialize Supabase client
        let supabaseClient = null;
        let gameChannel = null;
        let playersChannel = null;
        let currentGameId = null;

        if (SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY') {
            const { createClient } = supabase;
            supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        }
        // =================================================================

        // Game data structure
        const ROOMS_AND_TASKS = {
            "Anywhere": [
                "Power Down Protocol: Close your eyes, stand still, and count out loud for 30 seconds."
            ],
            "Outside": [
                "Stellar Navigation: Look at the sky for 20 seconds.",
                "Suspicious Surveillance: Stand in front of a neighbor's house for 20 seconds.",
                "House Boundary Scan: Touch all four outside corners of the house.",
                "Prepare the Runway: Lay down and roll across the driveway.",
                "Touch Grass: Remove your footwear and stand on the grass for 5 seconds.",
                "Test Comms: Put your head in the mailbox for 15 seconds."
            ],
            "Living Room": [
                "Living Room Groove: Dance in the living room for 20 seconds.",
                "Couch Compression Test: Sit on every seat cushion once.",
                "Remote Frequency Calibration: Find the TV remote and press any button.",
                "Light Sync: Turn a lamp off, then on again."
            ],
            "Kitchen": [
                "Heat Sensor Check: Open the oven/microwave door for 20 seconds, then close it.",
                "Cold Storage Audit: Open the fridge and name three items out loud.",
                "Utensil Sort: Use utensils to spell the word 'CREW' and then return them.",
                "Water Pressure Test: Run the sink for 3 seconds.",
                "Nutrient Calibration: Touch 3 different types of food and name them out loud."
            ],
            "Garage": [
                "Navigation Calibration: Touch all 4 corners of the garage.",
                "Tool Inventory Scan: Locate 3 different tools and name them out loud.",
                "Vehicle Diagnostics: Place your hand on a car tire for 20 seconds."
            ],
            "Bedrooms": [
                "Sleep Reset: Lie face down on a bed for 20 seconds.",
                "Meditation Moment: Assume a meditative pose and hold it for 20 seconds.",
                "Initialization Routine: Do 1 pushup, 1 sit-up, and 1 jumping jack."
            ],
            "Bathrooms": [
                "Emergency Water Reset: Turn both faucets on and off.",
                "Sit in a bathtub for 15 seconds."
            ],
            "Closets": [
                "Spend 10 seconds in three different closets. The door must be closed."
            ],
            "Office": [
                "Data Upload: Read a book in the office for 15 seconds."
            ],
            "Other": [
                "Put your head in the washing machine for 10 seconds.",
                "Put your head in the dryer for 10 seconds."
            ]
        };

        let gameState = {
            stage: 'setup',
            roomCode: '',
            hostName: null,
            settings: {
                minPlayers: 4,
                maxPlayers: 10,
                tasksPerPlayer: 4,
                imposterCount: 1,
                eliminationCooldown: 30,
                cooldownReduction: 5,
                meetingRoom: '',
                meetingLimit: 1,
                meetingTimer: 60,
                additionalRules: '',
                selectedRooms: {},
                uniqueTasks: []
            },
            players: [],
            currentPlayer: null,
            roleRevealed: false,
            meetingsUsed: 0,
            meetingCaller: null,
            meetingType: null,
            gameEnded: false,
            winner: null
        };

        // Track the player name for this device
        let myPlayerName = null;
        let isGameCreator = false; // True if this device created the game

        // Check if this device is the host
        function isHost() {
            // You're the host if you created the game OR if you're the named host
            const result = isGameCreator || (gameState.hostName && myPlayerName === gameState.hostName);
            console.log('isHost check - isGameCreator:', isGameCreator, '| hostName:', gameState.hostName, '| myPlayerName:', myPlayerName, '| result:', result);
            return result;
        }

        // ==================== SUPABASE HELPER FUNCTIONS ====================

        async function createGameInDB() {
            if (!supabaseClient) {
                console.warn('Supabase not configured - running in offline mode');
                return null;
            }

            try {
                const { data, error } = await supabaseClient
                    .from('games')
                    .insert({
                        room_code: gameState.roomCode,
                        host_name: null,  // Explicitly set as null initially, will be set when creator joins
                        stage: gameState.stage,
                        settings: gameState.settings,
                        meetings_used: gameState.meetingsUsed,
                        game_ended: gameState.gameEnded,
                        winner: gameState.winner
                    })
                    .select()
                    .single();

                if (error) throw error;

                currentGameId = data.id;
                console.log('Game created in DB:', data.id);

                // Subscribe to realtime updates
                subscribeToGame();
                subscribeToPlayers();

                return data;
            } catch (error) {
                console.error('Error creating game:', error);
                alert('Failed to create game in database. Playing in offline mode.');
                return null;
            }
        }

        async function joinGameFromDB(roomCode) {
            if (!supabaseClient) {
                console.warn('Supabase not configured');
                return null;
            }

            try {
                // Fetch game by room code
                const { data: gameData, error: gameError } = await supabaseClient
                    .from('games')
                    .select('*')
                    .eq('room_code', roomCode)
                    .single();

                if (gameError) throw gameError;

                currentGameId = gameData.id;

                // Load game state
                gameState.roomCode = gameData.room_code;
                gameState.hostName = gameData.host_name;
                gameState.stage = gameData.stage;
                gameState.settings = gameData.settings;
                gameState.meetingsUsed = gameData.meetings_used;
                gameState.gameEnded = gameData.game_ended;
                gameState.winner = gameData.winner;

                // Fetch players
                const { data: playersData, error: playersError } = await supabaseClient
                    .from('players')
                    .select('*')
                    .eq('game_id', currentGameId);

                if (playersError) throw playersError;

                gameState.players = playersData.map(p => ({
                    name: p.name,
                    role: p.role,
                    ready: p.ready,
                    tasks: p.tasks || [],
                    alive: p.alive,
                    tasksCompleted: p.tasks_completed || 0,
                    votedFor: p.voted_for
                }));

                // Subscribe to realtime updates
                subscribeToGame();
                subscribeToPlayers();

                console.log('Joined game from DB:', gameData.id);
                return gameData;
            } catch (error) {
                console.error('Error joining game:', error);
                return null;
            }
        }

        async function addPlayerToDB(playerName) {
            if (!supabaseClient || !currentGameId) {
                console.warn('Supabase not configured or no game ID');
                return null;
            }

            try {
                const { data, error } = await supabaseClient
                    .from('players')
                    .insert({
                        game_id: currentGameId,
                        name: playerName,
                        ready: true,
                        alive: true,
                        tasks: [],
                        tasks_completed: 0
                    })
                    .select()
                    .single();

                if (error) throw error;

                console.log('Player added to DB:', playerName);
                return data;
            } catch (error) {
                console.error('Error adding player:', error);
                return null;
            }
        }

        async function updateGameInDB() {
            if (!supabaseClient || !currentGameId) return;

            try {
                const { error } = await supabaseClient
                    .from('games')
                    .update({
                        stage: gameState.stage,
                        settings: gameState.settings,
                        meetings_used: gameState.meetingsUsed,
                        game_ended: gameState.gameEnded,
                        winner: gameState.winner
                    })
                    .eq('id', currentGameId);

                if (error) throw error;
            } catch (error) {
                console.error('Error updating game:', error);
            }
        }

        async function updatePlayerInDB(playerName, updates) {
            if (!supabaseClient || !currentGameId) return;

            try {
                const { error } = await supabaseClient
                    .from('players')
                    .update(updates)
                    .eq('game_id', currentGameId)
                    .eq('name', playerName);

                if (error) throw error;
            } catch (error) {
                console.error('Error updating player:', error);
            }
        }

        async function removePlayerFromDB(playerName) {
            if (!supabaseClient || !currentGameId) {
                console.warn('Cannot remove player from DB - supabaseClient or currentGameId missing');
                return;
            }

            try {
                console.log('Deleting player from DB:', playerName, 'game_id:', currentGameId);
                const { error } = await supabaseClient
                    .from('players')
                    .delete()
                    .eq('game_id', currentGameId)
                    .eq('name', playerName);

                if (error) throw error;
                console.log('Player deleted from DB successfully');
            } catch (error) {
                console.error('Error removing player:', error);
            }
        }

        function subscribeToGame() {
            if (!supabaseClient || !currentGameId) return;

            // Unsubscribe from previous channel if exists
            if (gameChannel) {
                supabaseClient.removeChannel(gameChannel);
            }

            gameChannel = supabaseClient
                .channel(`game:${currentGameId}`)
                .on('postgres_changes',
                    {
                        event: 'UPDATE',
                        schema: 'public',
                        table: 'games',
                        filter: `id=eq.${currentGameId}`
                    },
                    (payload) => {
                        console.log('Game updated:', payload);
                        const newData = payload.new;

                        // Update local state from DB
                        // Only update hostName if it's not null (prevent overwriting valid host with null)
                        if (newData.host_name !== null && newData.host_name !== undefined) {
                            gameState.hostName = newData.host_name;
                        }
                        gameState.stage = newData.stage;

                        // Only update settings if they exist (prevent overwriting valid settings with null/undefined)
                        if (newData.settings !== null && newData.settings !== undefined) {
                            gameState.settings = newData.settings;

                            // Sync meetingType from settings if it exists
                            if (newData.settings.meetingType) {
                                gameState.meetingType = newData.settings.meetingType;
                            }

                            // Check for new game invitation (for non-host players only)
                            console.log('Checking for invitation - isHost:', isHost(), 'invitation:', newData.settings.newGameInvitation, 'myPlayerName:', myPlayerName);
                            if (!isHost() && newData.settings.newGameInvitation && myPlayerName) {
                                console.log('=== NEW GAME INVITATION DETECTED ===');
                                console.log('Invitation type:', newData.settings.newGameInvitation);

                                // Hide waiting room and show invitation modal
                                // This ensures players can't see the waiting room until they accept
                                document.getElementById('waiting-room').classList.add('hidden');
                                document.getElementById('new-game-invitation').classList.remove('hidden');
                                console.log('Invitation modal shown, waiting room hidden');
                            }
                        }

                        gameState.meetingsUsed = newData.meetings_used;
                        gameState.gameEnded = newData.game_ended;
                        gameState.winner = newData.winner;

                        // Update UI based on stage
                        handleStageChange();

                        // Update host controls visibility
                        updateHostControls();
                    }
                )
                .subscribe();

            console.log('Subscribed to game updates');
        }

        function subscribeToPlayers() {
            if (!supabaseClient || !currentGameId) return;

            // Unsubscribe from previous channel if exists
            if (playersChannel) {
                supabaseClient.removeChannel(playersChannel);
            }

            playersChannel = supabaseClient
                .channel(`players:${currentGameId}`)
                .on('postgres_changes',
                    {
                        event: '*',
                        schema: 'public',
                        table: 'players',
                        filter: `game_id=eq.${currentGameId}`
                    },
                    (payload) => {
                        console.log('Players changed:', payload);
                        handlePlayerChange(payload);
                    }
                )
                .subscribe();

            console.log('Subscribed to player updates');
        }

        let playerExistenceInterval = null;

        function startPlayerExistenceCheck() {
            // Clear any existing interval
            if (playerExistenceInterval) {
                clearInterval(playerExistenceInterval);
            }

            // Wait 3 seconds before starting polling to ensure player is added to DB first
            setTimeout(() => {
                // Check every 2 seconds if this player still exists in the database
                playerExistenceInterval = setInterval(async () => {
                    if (!myPlayerName || !supabaseClient || !currentGameId) {
                        clearInterval(playerExistenceInterval);
                        return;
                    }

                    try {
                        const { data, error } = await supabaseClient
                            .from('players')
                            .select('name')
                            .eq('game_id', currentGameId)
                            .eq('name', myPlayerName)
                            .single();

                        if (error || !data) {
                            // Player no longer exists in database - we were kicked!
                            console.log('Player existence check: Player not found in DB - we were kicked!');
                            clearInterval(playerExistenceInterval);
                            alert('You have been removed from the game by the host.');
                            returnToMenu();
                        }
                    } catch (err) {
                        console.log('Player existence check error (likely kicked):', err);
                        clearInterval(playerExistenceInterval);
                        alert('You have been removed from the game by the host.');
                        returnToMenu();
                    }
                }, 2000);
            }, 3000);
        }

        function handlePlayerChange(payload) {
            const { eventType, new: newData, old: oldData } = payload;

            if (eventType === 'INSERT') {
                // New player joined
                const existingIndex = gameState.players.findIndex(p => p.name === newData.name);
                if (existingIndex === -1) {
                    gameState.players.push({
                        name: newData.name,
                        role: newData.role,
                        ready: newData.ready,
                        tasks: newData.tasks || [],
                        alive: newData.alive,
                        tasksCompleted: newData.tasks_completed || 0,
                        votedFor: newData.voted_for
                    });
                    updateLobby();
                }
            } else if (eventType === 'UPDATE') {
                // Player updated
                const playerIndex = gameState.players.findIndex(p => p.name === newData.name);
                if (playerIndex !== -1) {
                    gameState.players[playerIndex] = {
                        name: newData.name,
                        role: newData.role,
                        ready: newData.ready,
                        tasks: newData.tasks || [],
                        alive: newData.alive,
                        tasksCompleted: newData.tasks_completed || 0,
                        votedFor: newData.voted_for
                    };
                    updateLobby();
                }
            } else if (eventType === 'DELETE') {
                // Player left or was kicked
                console.log('DELETE event received for player:', oldData.name);
                console.log('Current myPlayerName:', myPlayerName);

                const playerIndex = gameState.players.findIndex(p => p.name === oldData.name);
                if (playerIndex !== -1) {
                    gameState.players.splice(playerIndex, 1);

                    // Check if the deleted player is this device's player
                    if (oldData.name === myPlayerName) {
                        console.log('This device was kicked! Redirecting to menu...');

                        // This player was kicked - notify and redirect
                        alert('You have been removed from the game by the host.');

                        // Return to menu
                        returnToMenu();
                    } else {
                        console.log('Someone else was kicked, updating lobby');
                        // Someone else left/was kicked - just update lobby
                        updateLobby();
                    }
                } else {
                    console.log('Player not found in local players array');
                }
            }
        }

        async function handleStageChange() {
            console.log('=== handleStageChange called ===');
            console.log('Current stage:', gameState.stage);
            console.log('myPlayerName:', myPlayerName);
            console.log('isHost():', isHost());

            // Show/hide appropriate UI sections based on stage
            if (gameState.stage === 'waiting') {
                console.log('Stage is WAITING');
                document.getElementById('setup-phase').classList.add('hidden');
                document.getElementById('game-phase').classList.add('hidden');
                document.getElementById('game-end').classList.add('hidden');

                // Check if an invitation modal is currently showing
                const invitationShowing = !document.getElementById('new-game-invitation').classList.contains('hidden');
                const nameConfirmationShowing = !document.getElementById('name-confirmation-modal').classList.contains('hidden');

                console.log('Invitation modal showing:', invitationShowing);
                console.log('Name confirmation modal showing:', nameConfirmationShowing);

                // Only hide waiting room if we're showing invitation or name confirmation
                // Otherwise, show it normally (for initial game joins)
                if (invitationShowing || nameConfirmationShowing) {
                    console.log('Hiding waiting room (modal is showing)');
                    document.getElementById('waiting-room').classList.add('hidden');
                } else {
                    console.log('Showing waiting room (no modals)');
                    document.getElementById('waiting-room').classList.remove('hidden');
                    updateLobby();
                }
            } else if (gameState.stage === 'playing') {
                // Set current player if not already set (for non-host players joining mid-game)
                if (!gameState.currentPlayer && myPlayerName) {
                    gameState.currentPlayer = myPlayerName;
                }

                // For non-host players, reload player data from DB to get roles/tasks
                if (myPlayerName && supabaseClient && currentGameId) {
                    try {
                        const { data, error } = await supabaseClient
                            .from('players')
                            .select('*')
                            .eq('game_id', currentGameId)
                            .eq('name', myPlayerName)
                            .single();

                        if (!error && data) {
                            // Update local player data with role and tasks from DB
                            const playerIndex = gameState.players.findIndex(p => p.name === myPlayerName);
                            if (playerIndex !== -1) {
                                gameState.players[playerIndex].role = data.role;
                                gameState.players[playerIndex].tasks = data.tasks || [];
                                gameState.players[playerIndex].tasksCompleted = data.tasks_completed || 0;
                                console.log('Loaded player data from DB:', data);
                            }
                        }
                    } catch (err) {
                        console.error('Error loading player data:', err);
                    }
                }

                document.getElementById('waiting-room').classList.add('hidden');
                document.getElementById('game-phase').classList.remove('hidden');
                displayGameplay();
            } else if (gameState.stage === 'meeting') {
                // Show meeting alert for all players
                console.log('Meeting stage detected, showing alert');
                document.getElementById('meeting-location-alert').textContent = gameState.settings.meetingRoom;
                document.getElementById('meeting-overlay').classList.remove('hidden');

                // Only show meeting controls for the player who called the meeting
                if (myPlayerName === gameState.meetingCaller) {
                    document.getElementById('meeting-caller-controls').classList.remove('hidden');
                } else {
                    document.getElementById('meeting-caller-controls').classList.add('hidden');
                }

                // Play alarm sound for everyone
                playAlarmSound();
            } else if (gameState.stage === 'ended') {
                // Game has ended - show end screen
                console.log('Game ended stage detected');

                // Hide other phases
                document.getElementById('game-phase').classList.add('hidden');
                document.getElementById('meeting-phase').classList.add('hidden');
                document.getElementById('waiting-room').classList.add('hidden');

                // Show game end screen
                document.getElementById('game-end').classList.remove('hidden');

                // Determine if this player won or lost
                const player = gameState.players.find(p => p.name === myPlayerName);
                const playerRole = player ? player.role : null;

                // Crewmates win if winner is 'crewmates', imposters win if winner is 'imposters'
                const didPlayerWin = (playerRole === 'crewmate' && gameState.winner === 'crewmates') ||
                                     (playerRole === 'imposter' && gameState.winner === 'imposters');

                // Show appropriate screen
                if (didPlayerWin) {
                    document.getElementById('victory-screen').classList.remove('hidden');
                    document.getElementById('defeat-screen').classList.add('hidden');
                    if (gameState.settings && gameState.settings.meetingRoom) {
                        document.getElementById('meeting-location-victory').textContent = gameState.settings.meetingRoom;
                    }
                } else {
                    document.getElementById('victory-screen').classList.add('hidden');
                    document.getElementById('defeat-screen').classList.remove('hidden');
                    if (gameState.settings && gameState.settings.meetingRoom) {
                        document.getElementById('meeting-location-defeat').textContent = gameState.settings.meetingRoom;
                    }
                }

                // Populate game summary
                populateGameSummary();

                // Show host controls if this player is the host
                if (isHost()) {
                    document.getElementById('host-game-controls').classList.remove('hidden');
                }
            }
        }

        function unsubscribeFromChannels() {
            if (gameChannel) {
                supabaseClient.removeChannel(gameChannel);
                gameChannel = null;
            }
            if (playersChannel) {
                supabaseClient.removeChannel(playersChannel);
                playersChannel = null;
            }
        }

        // =================================================================

        // Initialize rooms/tasks UI
        function initializeRoomsAndTasks() {
            const container = document.getElementById('rooms-tasks-container');

            container.innerHTML = '';

            console.log('ROOMS_AND_TASKS keys:', Object.keys(ROOMS_AND_TASKS));
            console.log('Total rooms:', Object.keys(ROOMS_AND_TASKS).length);

            Object.keys(ROOMS_AND_TASKS).forEach(roomName => {
                console.log('Initializing room:', roomName);
                // Initialize in gameState
                gameState.settings.selectedRooms[roomName] = {
                    enabled: true,
                    tasks: ROOMS_AND_TASKS[roomName].map((task, i) => ({
                        name: task,
                        enabled: true,
                        unique: false
                    }))
                };
            });

            console.log('gameState.settings.selectedRooms:', Object.keys(gameState.settings.selectedRooms));
            renderAllRooms();

            // Add "Add Room" button
            const addRoomBtn = document.createElement('button');
            addRoomBtn.id = 'add-room-btn';
            addRoomBtn.className = 'btn-primary';
            addRoomBtn.style.marginTop = '15px';
            addRoomBtn.innerHTML = '‚ûï Add Room';
            addRoomBtn.onclick = showAddRoomModal;
            container.appendChild(addRoomBtn);
        }

        function renderAllRooms() {
            const container = document.getElementById('rooms-tasks-container');

            // Clear all room sections (but keep the add room button if it exists)
            const sections = container.querySelectorAll('.room-section');
            sections.forEach(section => section.remove());

            console.log('renderAllRooms - Rooms to render:', Object.keys(gameState.settings.selectedRooms));
            Object.keys(gameState.settings.selectedRooms).forEach(roomName => {
                console.log('Rendering room:', roomName);
                renderRoom(roomName);
            });
        }

        function renderRoom(roomName) {
            const container = document.getElementById('rooms-tasks-container');
            const addRoomBtn = document.getElementById('add-room-btn');

            const roomSection = document.createElement('div');
            roomSection.className = 'room-section';
            roomSection.id = `room-section-${roomName}`;

            const roomHeader = document.createElement('div');
            roomHeader.className = 'room-header';
            roomHeader.innerHTML = `
                <input type="checkbox" class="room-checkbox" id="room-${roomName}" onchange="toggleRoom('${roomName}')" ${gameState.settings.selectedRooms[roomName].enabled ? 'checked' : ''}>
                <label for="room-${roomName}" style="font-weight: 600; font-size: 1.1rem;">${roomName}</label>
                <button onclick="deleteRoom('${roomName}')" style="background: #ff3838; color: white; border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer; margin-left: auto; font-size: 0.9rem;">üóëÔ∏è Delete</button>
            `;

            const taskList = document.createElement('ul');
            taskList.className = 'task-list';
            taskList.id = `tasks-${roomName}`;

            gameState.settings.selectedRooms[roomName].tasks.forEach((task, index) => {
                renderTask(roomName, index, taskList);
            });

            // Add "Add Task" button
            const addTaskBtn = document.createElement('button');
            addTaskBtn.className = 'btn-primary';
            addTaskBtn.style.marginTop = '10px';
            addTaskBtn.style.marginLeft = '30px';
            addTaskBtn.style.padding = '8px 15px';
            addTaskBtn.style.fontSize = '0.9rem';
            addTaskBtn.innerHTML = '‚ûï Add Task';
            addTaskBtn.onclick = () => showAddTaskModal(roomName);

            roomSection.appendChild(roomHeader);
            roomSection.appendChild(taskList);
            roomSection.appendChild(addTaskBtn);

            // Insert before the "Add Room" button or at the end
            if (addRoomBtn) {
                container.insertBefore(roomSection, addRoomBtn);
            } else {
                container.appendChild(roomSection);
            }
        }

        function renderTask(roomName, taskIndex, taskList) {
            const task = gameState.settings.selectedRooms[roomName].tasks[taskIndex];
            const taskItem = document.createElement('li');
            taskItem.className = 'task-item';
            taskItem.id = `task-item-${roomName}-${taskIndex}`;

            const isRoomDisabled = !gameState.settings.selectedRooms[roomName].enabled;

            taskItem.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 10px; flex: 1;">
                    <input type="checkbox" id="task-${roomName}-${taskIndex}" ${task.enabled ? 'checked' : ''} ${isRoomDisabled ? 'disabled' : ''} onchange="toggleTaskEnabled('${roomName}', ${taskIndex})" class="task-enable-checkbox">
                    <label for="task-${roomName}-${taskIndex}" style="flex: 1;" id="task-label-${roomName}-${taskIndex}">${task.name}</label>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <button onclick="editTask('${roomName}', ${taskIndex})" style="background: #5eb3f6; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">‚úèÔ∏è</button>
                    <button onclick="deleteTask('${roomName}', ${taskIndex})" style="background: #ff3838; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">üóëÔ∏è</button>
                </div>
                <div class="unique-control" style="display: none; align-items: center; gap: 5px;">
                    <input type="checkbox" id="unique-${roomName}-${taskIndex}" ${task.unique ? 'checked' : ''} onchange="toggleTaskUnique('${roomName}', ${taskIndex})" style="width: 16px; height: 16px;">
                    <label for="unique-${roomName}-${taskIndex}" style="font-size: 0.85rem; color: #ff9800; white-space: nowrap; cursor: pointer;">Unique</label>
                </div>
            `;

            taskList.appendChild(taskItem);
        }

        // Room CRUD operations
        function showAddRoomModal() {
            const roomName = prompt('Enter room name:');
            if (roomName && roomName.trim()) {
                const trimmedName = roomName.trim();
                if (gameState.settings.selectedRooms[trimmedName]) {
                    alert('A room with this name already exists!');
                    return;
                }
                addRoom(trimmedName);
            }
        }

        function addRoom(roomName) {
            gameState.settings.selectedRooms[roomName] = {
                enabled: true,
                tasks: []
            };
            renderRoom(roomName);
            updateMeetingRoomDropdown();
        }

        function deleteRoom(roomName) {
            if (confirm(`Are you sure you want to delete the room "${roomName}" and all its tasks?`)) {
                delete gameState.settings.selectedRooms[roomName];
                const roomSection = document.getElementById(`room-section-${roomName}`);
                if (roomSection) {
                    roomSection.remove();
                }
                updateMeetingRoomDropdown();
            }
        }

        // Task CRUD operations
        function showAddTaskModal(roomName) {
            const taskName = prompt('Enter task description:');
            if (taskName && taskName.trim()) {
                addTask(roomName, taskName.trim());
            }
        }

        function addTask(roomName, taskName) {
            gameState.settings.selectedRooms[roomName].tasks.push({
                name: taskName,
                enabled: true,
                unique: false
            });

            const taskList = document.getElementById(`tasks-${roomName}`);
            const taskIndex = gameState.settings.selectedRooms[roomName].tasks.length - 1;
            renderTask(roomName, taskIndex, taskList);

            // Apply current unique visibility setting
            toggleUniqueVisibility();
        }

        function editTask(roomName, taskIndex) {
            const currentTask = gameState.settings.selectedRooms[roomName].tasks[taskIndex];
            const newTaskName = prompt('Edit task description:', currentTask.name);

            if (newTaskName && newTaskName.trim()) {
                gameState.settings.selectedRooms[roomName].tasks[taskIndex].name = newTaskName.trim();
                const label = document.getElementById(`task-label-${roomName}-${taskIndex}`);
                if (label) {
                    label.textContent = newTaskName.trim();
                }
            }
        }

        function deleteTask(roomName, taskIndex) {
            gameState.settings.selectedRooms[roomName].tasks.splice(taskIndex, 1);

            // Re-render all tasks in this room to fix indices
            const taskList = document.getElementById(`tasks-${roomName}`);
            taskList.innerHTML = '';
            gameState.settings.selectedRooms[roomName].tasks.forEach((task, index) => {
                renderTask(roomName, index, taskList);
            });

            // Apply current unique visibility setting
            toggleUniqueVisibility();
        }

        function toggleCollapsible(element) {
            element.classList.toggle('active');
            const content = element.nextElementSibling;
            content.classList.toggle('active');
        }

        function updateMeetingRoomDropdown() {
            const meetingRoomSelect = document.getElementById('meeting-room');
            const currentValue = meetingRoomSelect.value;

            // Clear and rebuild dropdown
            meetingRoomSelect.innerHTML = '<option value="">Select a room...</option>';

            // Only add enabled rooms
            Object.keys(gameState.settings.selectedRooms).forEach(roomName => {
                if (gameState.settings.selectedRooms[roomName].enabled) {
                    const option = document.createElement('option');
                    option.value = roomName;
                    option.textContent = roomName;
                    meetingRoomSelect.appendChild(option);
                }
            });

            // Restore previous selection if room is still enabled
            if (currentValue && gameState.settings.selectedRooms[currentValue]?.enabled) {
                meetingRoomSelect.value = currentValue;
            }
        }

        function toggleRoom(roomName) {
            const checkbox = document.getElementById(`room-${roomName}`);
            const taskList = document.getElementById(`tasks-${roomName}`);
            taskList.style.opacity = checkbox.checked ? '1' : '0.3';
            gameState.settings.selectedRooms[roomName].enabled = checkbox.checked;

            // When unchecking a room, also uncheck and disable all its tasks
            if (!checkbox.checked) {
                gameState.settings.selectedRooms[roomName].tasks.forEach((task, index) => {
                    const taskCheckbox = document.getElementById(`task-${roomName}-${index}`);
                    if (taskCheckbox) {
                        taskCheckbox.checked = false;
                        taskCheckbox.disabled = true;
                        task.enabled = false;
                    }
                });
            } else {
                // When checking a room, re-enable all its tasks
                gameState.settings.selectedRooms[roomName].tasks.forEach((task, index) => {
                    const taskCheckbox = document.getElementById(`task-${roomName}-${index}`);
                    if (taskCheckbox) {
                        taskCheckbox.checked = true;
                        taskCheckbox.disabled = false;
                        task.enabled = true;
                    }
                });
            }

            // Update meeting room dropdown to reflect enabled rooms
            updateMeetingRoomDropdown();
        }

        function toggleTaskEnabled(roomName, taskIndex) {
            const checkbox = document.getElementById(`task-${roomName}-${taskIndex}`);
            gameState.settings.selectedRooms[roomName].tasks[taskIndex].enabled = checkbox.checked;
        }

        function toggleTaskUnique(roomName, taskIndex) {
            const checkbox = document.getElementById(`unique-${roomName}-${taskIndex}`);
            gameState.settings.selectedRooms[roomName].tasks[taskIndex].unique = checkbox.checked;
        }

        function toggleUniqueVisibility() {
            const uniqueMode = document.querySelector('input[name="unique-mode"]:checked').value;
            const uniqueControls = document.querySelectorAll('.unique-control');

            if (uniqueMode === 'manual') {
                uniqueControls.forEach(control => {
                    control.style.display = 'flex';
                });
            } else {
                uniqueControls.forEach(control => {
                    control.style.display = 'none';
                });
            }
        }

        function setupUniqueRadioListeners() {
            const radioButtons = document.querySelectorAll('input[name="unique-mode"]');
            radioButtons.forEach(radio => {
                radio.addEventListener('change', toggleUniqueVisibility);
            });
        }

        // ==================== MENU NAVIGATION ====================

        function showCreateGame() {
            // Hide menu, show setup phase
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('setup-phase').classList.remove('hidden');
        }

        function showJoinGame() {
            // Show the join game input section on the menu
            document.getElementById('join-game-section').classList.remove('hidden');
        }

        function hideJoinGame() {
            // Hide the join game input section
            document.getElementById('join-game-section').classList.add('hidden');
            document.getElementById('menu-room-code-input').value = '';
        }

        async function joinGameFromMenu() {
            const roomCodeInput = document.getElementById('menu-room-code-input');
            const roomCode = roomCodeInput.value.trim().toUpperCase();

            if (roomCode.length !== 4) {
                alert('Please enter a valid 4-letter room code.');
                return;
            }

            if (!supabaseClient) {
                alert('Online multiplayer not available. Please configure Supabase.');
                return;
            }

            // Try to join the game from database
            const gameData = await joinGameFromDB(roomCode);

            if (gameData) {
                // Successfully found game - hide menu, show waiting room
                document.getElementById('main-menu').classList.add('hidden');
                document.getElementById('setup-phase').classList.add('hidden');
                document.getElementById('waiting-room').classList.remove('hidden');
                document.getElementById('room-code').textContent = roomCode;

                // Update displays
                document.getElementById('min-players-display').textContent = gameState.settings.minPlayers;
                document.getElementById('max-players-display').textContent = gameState.settings.maxPlayers;
                document.getElementById('imposter-count-display').textContent = gameState.settings.imposterCount;

                // Generate QR code
                generateQRCode();
                updateJoinSection();
                updateLobby();
            } else {
                alert(`Game with room code "${roomCode}" not found. Please check the code and try again.`);
            }
        }

        function returnToMenu() {
            // Stop player existence polling
            if (playerExistenceInterval) {
                clearInterval(playerExistenceInterval);
                playerExistenceInterval = null;
            }

            // Unsubscribe from channels FIRST to prevent callbacks from firing
            unsubscribeFromChannels();

            // Clear player state
            myPlayerName = null;
            isGameCreator = false;

            // Clear game state
            gameState = {
                stage: 'setup',
                roomCode: '',
                hostName: null,
                settings: {
                    minPlayers: 4,
                    maxPlayers: 10,
                    tasksPerPlayer: 3,
                    imposterCount: 1,
                    eliminationCooldown: 30,
                    cooldownReduction: 5,
                    meetingRoom: '',
                    meetingLimit: 3,
                    meetingTimer: 60,
                    additionalRules: '',
                    selectedRooms: {}
                },
                players: [],
                currentPlayer: null,
                roleRevealed: false,
                meetingsUsed: 0,
                meetingCaller: null,
                meetingType: null,
                gameEnded: false,
                winner: null
            };

            // Hide all phases, show menu
            document.getElementById('setup-phase').classList.add('hidden');
            document.getElementById('waiting-room').classList.add('hidden');
            document.getElementById('game-phase').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');

            // Hide join section
            hideJoinGame();
        }

        // =================================================================

        function generateRoomCode() {
            const characters = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return code;
        }

        function getGameURL() {
            const baseUrl = window.location.origin + window.location.pathname;
            return `${baseUrl}?room=${gameState.roomCode}`;
        }

        function copyGameURL() {
            const url = getGameURL();
            navigator.clipboard.writeText(url).then(() => {
                const feedback = document.getElementById('copy-feedback');
                feedback.style.opacity = '1';
                setTimeout(() => feedback.style.opacity = '0', 2000);
            });
        }

        function generateQRCode() {
            const url = getGameURL();
            const qrCodeImage = document.getElementById('qr-code-image');
            // Use QR Server API to generate QR code
            const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=${encodeURIComponent(url)}`;
            qrCodeImage.src = qrApiUrl;
        }

        async function createGame() {
            // Gather settings
            gameState.settings.minPlayers = parseInt(document.getElementById('min-players').value);
            gameState.settings.maxPlayers = parseInt(document.getElementById('max-players').value);
            gameState.settings.tasksPerPlayer = parseInt(document.getElementById('tasks-per-player').value);
            gameState.settings.imposterCount = parseInt(document.getElementById('imposter-count').value);
            gameState.settings.eliminationCooldown = parseInt(document.getElementById('elimination-cooldown').value);
            gameState.settings.cooldownReduction = parseInt(document.getElementById('cooldown-reduction').value);
            gameState.settings.meetingRoom = document.getElementById('meeting-room').value;
            gameState.settings.meetingLimit = parseInt(document.getElementById('meeting-limit').value);
            gameState.settings.meetingTimer = parseInt(document.getElementById('meeting-timer').value);
            gameState.settings.additionalRules = document.getElementById('additional-rules').value;

            // Validation
            if (gameState.settings.minPlayers > gameState.settings.maxPlayers) {
                alert('Minimum players cannot be greater than maximum players!');
                return;
            }

            if (!gameState.settings.meetingRoom) {
                alert('Please select a meeting room!');
                return;
            }

            // Mark this device as the game creator FIRST (before any UI updates that check host status)
            isGameCreator = true;
            console.log('Game created - isGameCreator set to true');

            // Generate room code
            gameState.roomCode = generateRoomCode();
            document.getElementById('room-code').textContent = gameState.roomCode;

            // Update displays
            document.getElementById('min-players-display').textContent = gameState.settings.minPlayers;
            document.getElementById('max-players-display').textContent = gameState.settings.maxPlayers;
            document.getElementById('imposter-count-display').textContent = gameState.settings.imposterCount;

            // Check if this is a new game after a previous one (need to send invitations)
            const isNewGameAfterPrevious = gameState.isNewGameAfterPrevious || false;

            if (isNewGameAfterPrevious && supabaseClient && currentGameId) {
                console.log('This is a new game after previous - sending invitations');

                // Send invitation to players from previous game
                try {
                    await supabaseClient
                        .from('games')
                        .update({
                            settings: {
                                ...gameState.settings,
                                newGameInvitation: 'new_game',
                                invitationTimestamp: new Date().toISOString()
                            }
                        })
                        .eq('id', currentGameId);

                    console.log('Invitation sent to previous players');

                    // Wait a moment for invitation to propagate
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Clear the invitation flag
                    delete gameState.settings.newGameInvitation;
                    delete gameState.settings.invitationTimestamp;
                    gameState.isNewGameAfterPrevious = false;
                } catch (err) {
                    console.error('Error sending invitation:', err);
                }
            }

            // Switch to waiting room
            gameState.stage = 'waiting';
            document.getElementById('setup-phase').classList.add('hidden');
            document.getElementById('waiting-room').classList.remove('hidden');

            // Generate QR code for joining
            generateQRCode();

            // Update join section to show correct view (now isHost() will return true)
            updateJoinSection();

            // Create game in database - WAIT for it to complete so currentGameId is set
            await createGameInDB();
            console.log('Database ready - currentGameId:', currentGameId);
        }

        function showInstructions() {
            document.getElementById('additional-rules-display').textContent =
                gameState.settings.additionalRules || 'No additional rules specified.';
            document.getElementById('instructions-modal').classList.remove('hidden');
        }

        function closeInstructions() {
            document.getElementById('instructions-modal').classList.add('hidden');
        }

        function editSettings() {
            if (!isHost()) {
                alert('Only the host can edit settings!');
                return;
            }

            if (confirm('Are you sure you want to edit settings? This will return you to the setup screen.')) {
                document.getElementById('waiting-room').classList.add('hidden');
                document.getElementById('setup-phase').classList.remove('hidden');
            }
        }

        async function joinGame() {
            const nameInput = document.getElementById('player-name-input');
            const name = nameInput.value.trim();

            if (!name) {
                alert('Please enter your name!');
                return;
            }

            if (gameState.players.length >= gameState.settings.maxPlayers) {
                document.getElementById('room-full-message').classList.remove('hidden');
                return;
            }

            // Check if player already exists (reconnection case)
            const existingPlayer = gameState.players.find(p => p.name.toLowerCase() === name.toLowerCase());
            if (existingPlayer) {
                // Reconnect as this player
                myPlayerName = existingPlayer.name;
                nameInput.value = '';
                updateJoinSection();
                console.log('Reconnected as existing player:', name);

                // Update last_seen in database
                if (supabaseClient && currentGameId) {
                    await updatePlayerInDB(existingPlayer.name, { last_seen: new Date().toISOString() });
                }

                // Start polling to detect if we get kicked
                startPlayerExistenceCheck();
                return;
            }

            gameState.players.push({
                name: name,
                ready: true,
                role: null,
                tasks: [],
                alive: true,
                tasksCompleted: 0
            });

            // Track this device's player
            myPlayerName = name;
            console.log('Player joined:', name, '| isGameCreator:', isGameCreator, '| currentGameId:', currentGameId, '| current hostName:', gameState.hostName);

            // If this device created the game and there's no host yet, set this player as host
            // Defensive check: only set as host if hostName is null or undefined
            if (isGameCreator && (gameState.hostName === null || gameState.hostName === undefined)) {
                gameState.hostName = name;
                console.log('Setting host:', name);

                // Update host in database
                if (supabaseClient && currentGameId) {
                    const { error } = await supabaseClient
                        .from('games')
                        .update({ host_name: name })
                        .eq('id', currentGameId);

                    if (error) {
                        console.error('Failed to set host in database:', error);
                    } else {
                        console.log('Host successfully set in database');
                    }
                } else {
                    console.warn('Cannot set host in database - supabaseClient or currentGameId missing');
                }
            } else {
                console.log('Not setting as host - isGameCreator:', isGameCreator, 'gameState.hostName:', gameState.hostName);
            }

            nameInput.value = '';
            updateJoinSection();
            updateLobby();

            // Add player to database
            await addPlayerToDB(name);

            // Start polling to detect if we get kicked
            startPlayerExistenceCheck();
        }

        function updateJoinSection() {
            if (myPlayerName) {
                // Hide join form, show already joined view
                document.getElementById('join-form').classList.add('hidden');
                document.getElementById('already-joined').classList.remove('hidden');
                document.getElementById('my-player-name').textContent = myPlayerName;
            } else {
                // Show join form, hide already joined view
                document.getElementById('join-form').classList.remove('hidden');
                document.getElementById('already-joined').classList.add('hidden');
            }

            // Update host controls visibility
            updateHostControls();
        }

        function updateLobby() {
            // Safety check - only skip if we're not in waiting stage (prevents errors during menu transition)
            if (gameState.stage !== 'waiting') {
                console.log('updateLobby called but not in waiting stage, ignoring');
                return;
            }

            // Additional safety check - ensure settings exist
            if (!gameState.settings || !gameState.settings.minPlayers) {
                console.log('updateLobby called but settings not initialized, ignoring');
                return;
            }

            const lobbyDiv = document.getElementById('lobby-players');
            if (!lobbyDiv) {
                console.log('lobby-players element not found');
                return;
            }

            lobbyDiv.innerHTML = '';

            const readyPlayers = gameState.players.filter(p => p.ready);

            gameState.players.forEach((player, index) => {
                const badge = document.createElement('div');
                badge.className = `player-badge ${player.ready ? 'player-ready' : ''}`;

                const isPlayerHost = player.name === gameState.hostName;
                const showKickButton = isHost() && player.name !== myPlayerName;

                badge.innerHTML = `
                    <span>${player.name} ${isPlayerHost ? 'üëë' : ''}</span>
                    <div>
                        ${player.ready ? '<span class="ready-indicator">Ready</span>' : ''}
                        ${showKickButton ? `<button onclick="kickPlayer('${player.name}')" style="background: #ff3838; color: white; border: none; padding: 4px 12px; border-radius: 4px; cursor: pointer; margin-left: 10px; font-size: 0.85rem;">Kick</button>` : ''}
                    </div>
                `;
                lobbyDiv.appendChild(badge);
            });

            document.getElementById('ready-count').textContent = readyPlayers.length;
            document.getElementById('ready-list-count').textContent = readyPlayers.length;
            document.getElementById('joined-count').textContent = gameState.players.length;

            // Update start button - must be host AND have enough players
            const startBtn = document.getElementById('start-game-btn');
            const enoughPlayers = readyPlayers.length >= gameState.settings.minPlayers;
            const userIsHost = isHost();

            if (!userIsHost) {
                // Non-host: always disabled
                startBtn.disabled = true;
                startBtn.textContent = 'Only host can start the game';
            } else if (!enoughPlayers) {
                // Host but not enough players: disabled
                startBtn.disabled = true;
                startBtn.textContent = `Start Game (Waiting for minimum players to be ready)`;
            } else {
                // Host with enough players: enabled
                startBtn.disabled = false;
                startBtn.textContent = 'Start Game';
            }

            // Update other host controls
            updateHostControls();
        }

        function updateHostControls() {
            // Show/hide Edit Settings button based on host status
            const editSettingsBtn = document.getElementById('edit-settings-btn');

            if (editSettingsBtn) {
                if (isHost()) {
                    editSettingsBtn.style.display = '';
                } else {
                    editSettingsBtn.style.display = 'none';
                }
            }

            // Note: Start button is handled in updateLobby() to coordinate with player count
        }

        async function kickPlayer(playerName) {
            if (!isHost()) {
                alert('Only the host can kick players!');
                return;
            }

            if (confirm(`Are you sure you want to kick ${playerName}?`)) {
                console.log('Host kicking player:', playerName);

                // Remove from local state
                const playerIndex = gameState.players.findIndex(p => p.name === playerName);
                if (playerIndex !== -1) {
                    gameState.players.splice(playerIndex, 1);
                    console.log('Removed from local state');
                }

                // Remove from database
                console.log('Calling removePlayerFromDB...');
                await removePlayerFromDB(playerName);
                console.log('removePlayerFromDB completed');

                updateLobby();
            }
        }

        function editMyName() {
            if (!myPlayerName) return;

            const playerIndex = gameState.players.findIndex(p => p.name === myPlayerName);
            if (playerIndex === -1) return;

            const player = gameState.players[playerIndex];
            const newName = prompt('Enter new name:', player.name);

            if (newName === null || newName.trim() === '') {
                return; // User cancelled or entered empty name
            }

            const trimmedName = newName.trim();

            // Check if new name is different from current name
            if (trimmedName.toLowerCase() === player.name.toLowerCase()) {
                return; // No change needed
            }

            // Case-insensitive duplicate check (excluding current player)
            if (gameState.players.some((p, i) => i !== playerIndex && p.name.toLowerCase() === trimmedName.toLowerCase())) {
                alert('This name is already taken!');
                return;
            }

            // Update the player's name
            const oldName = player.name;
            player.name = trimmedName;
            myPlayerName = trimmedName;
            updateJoinSection();
            updateLobby();

            // Update in database - need to delete old and insert new (since name is part of unique constraint)
            if (supabaseClient && currentGameId) {
                removePlayerFromDB(oldName).then(() => {
                    addPlayerToDB(trimmedName);
                });
            }
        }

        function leaveGame() {
            if (!myPlayerName) return;

            if (confirm('Are you sure you want to leave the game?')) {
                const playerIndex = gameState.players.findIndex(p => p.name === myPlayerName);
                const playerName = myPlayerName;
                if (playerIndex !== -1) {
                    gameState.players.splice(playerIndex, 1);
                }
                myPlayerName = null;
                updateJoinSection();
                updateLobby();

                // Remove from database
                removePlayerFromDB(playerName);
            }
        }

        function startGame() {
            // Only host can start the game
            if (!isHost()) {
                alert('Only the host can start the game!');
                return;
            }

            // Assign roles
            const shuffled = [...gameState.players].sort(() => Math.random() - 0.5);
            const imposterNames = shuffled.slice(0, gameState.settings.imposterCount).map(p => p.name);

            // Collect all enabled tasks from selected rooms
            const allTasks = [];
            const uniqueTasks = [];

            Object.keys(gameState.settings.selectedRooms).forEach(roomName => {
                const room = gameState.settings.selectedRooms[roomName];
                if (room.enabled) {
                    room.tasks.forEach(task => {
                        if (task.enabled) {
                            const taskObj = { room: roomName, task: task.name };
                            if (task.unique) {
                                uniqueTasks.push(taskObj);
                            } else {
                                allTasks.push(taskObj);
                            }
                        }
                    });
                }
            });

            // Assign tasks to players
            gameState.players.forEach(player => {
                player.role = imposterNames.includes(player.name) ? 'imposter' : 'crewmate';
                player.alive = true;
                player.tasksCompleted = 0;

                // Assign tasks based on role
                const assignedTasks = [];
                const isImposter = player.role === 'imposter';

                // For imposters: only non-unique tasks (dummy tasks for appearance)
                // For crewmates: mix of unique and non-unique tasks
                const availableNonUnique = [...allTasks];
                const availableUnique = isImposter ? [] : [...uniqueTasks];

                // Shuffle available tasks
                availableNonUnique.sort(() => Math.random() - 0.5);
                availableUnique.sort(() => Math.random() - 0.5);

                // Assign the required number of tasks
                for (let i = 0; i < gameState.settings.tasksPerPlayer; i++) {
                    // Try to assign unique task first (crewmates only)
                    if (availableUnique.length > 0 && Math.random() < 0.3) {
                        const uniqueTask = availableUnique.shift();
                        assignedTasks.push(uniqueTask);
                    } else if (availableNonUnique.length > 0) {
                        // Assign regular task (can be reused across players)
                        const taskIndex = Math.floor(Math.random() * availableNonUnique.length);
                        assignedTasks.push(availableNonUnique[taskIndex]);
                    }
                }

                player.tasks = assignedTasks;
            });

            // Set current player based on this device's player (if joined)
            if (myPlayerName) {
                gameState.currentPlayer = myPlayerName;
            } else {
                // Default to first player if not joined (for host view)
                gameState.currentPlayer = gameState.players[0]?.name || null;
            }

            // Switch to game phase
            gameState.stage = 'playing';
            document.getElementById('waiting-room').classList.add('hidden');
            document.getElementById('game-phase').classList.remove('hidden');

            displayGameplay();

            // Update game state in database
            updateGameInDB();

            // Update all players with their roles/tasks in database
            if (supabaseClient && currentGameId) {
                gameState.players.forEach(player => {
                    updatePlayerInDB(player.name, {
                        role: player.role,
                        tasks: player.tasks,
                        alive: player.alive,
                        tasks_completed: player.tasksCompleted
                    });
                });
            }
        }

        function displayGameplay() {
            const player = gameState.players.find(p => p.name === gameState.currentPlayer);
            if (!player) return;

            // Display actual role but with same color styling for both (prevents visual giveaways)
            const roleText = player.role.charAt(0).toUpperCase() + player.role.slice(1);
            document.getElementById('role-text').textContent = roleText;
            // Both roles use the same color class to avoid visual giveaways
            document.getElementById('role-text').className = 'role-revealed role-crewmate';

            document.getElementById('meetings-remaining').textContent =
                gameState.settings.meetingLimit - gameState.meetingsUsed;

            // Render player's task list
            renderPlayerTasks();
        }

        function renderPlayerTasks() {
            const player = gameState.players.find(p => p.name === gameState.currentPlayer);
            if (!player) return;

            const tasksContainer = document.getElementById('player-tasks');
            const completedCount = document.getElementById('completed-tasks-count');
            const totalCount = document.getElementById('total-tasks-count');

            tasksContainer.innerHTML = '';
            completedCount.textContent = player.tasksCompleted || 0;
            totalCount.textContent = player.tasks.length;

            // Display each task with a checkbox
            player.tasks.forEach((taskObj, index) => {
                const taskItem = document.createElement('div');
                taskItem.style.cssText = 'display: flex; align-items: center; padding: 8px; margin-bottom: 5px; background: rgba(255,255,255,0.05); border-radius: 5px;';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `task-${index}`;
                checkbox.style.cssText = 'margin-right: 10px; width: 18px; height: 18px; cursor: pointer;';
                checkbox.checked = index < (player.tasksCompleted || 0);

                // Only allow crewmates to actually complete tasks (imposters' checks are cosmetic)
                checkbox.onchange = () => toggleTaskComplete(index);

                const label = document.createElement('label');
                label.htmlFor = `task-${index}`;
                label.style.cssText = 'flex: 1; cursor: pointer; color: #fff;';
                label.textContent = `${taskObj.task} (${taskObj.room})`;

                taskItem.appendChild(checkbox);
                taskItem.appendChild(label);
                tasksContainer.appendChild(taskItem);
            });
        }

        function toggleTaskComplete(taskIndex) {
            const player = gameState.players.find(p => p.name === gameState.currentPlayer);
            if (!player) return;

            const checkbox = document.getElementById(`task-${taskIndex}`);

            if (checkbox.checked) {
                // Task completed
                player.tasksCompleted = Math.min((player.tasksCompleted || 0) + 1, player.tasks.length);
            } else {
                // Task unchecked
                player.tasksCompleted = Math.max((player.tasksCompleted || 0) - 1, 0);
            }

            // Update the count display
            document.getElementById('completed-tasks-count').textContent = player.tasksCompleted;

            // Only update database for crewmates (imposters' tasks are dummy)
            if (player.role === 'crewmate') {
                // Update player in database
                if (supabaseClient && currentGameId) {
                    updatePlayerInDB(player.name, {
                        tasks_completed: player.tasksCompleted
                    });
                }

                // Check if crewmates won
                checkCrewmateVictory();
            }
        }

        function checkCrewmateVictory() {
            // Count total tasks and completed tasks for all crewmates
            let totalCrewmateTasks = 0;
            let completedCrewmateTasks = 0;

            gameState.players.forEach(player => {
                if (player.role === 'crewmate' && player.alive) {
                    totalCrewmateTasks += player.tasks.length;
                    completedCrewmateTasks += player.tasksCompleted || 0;
                }
            });

            // Check if all tasks are completed
            if (totalCrewmateTasks > 0 && completedCrewmateTasks >= totalCrewmateTasks) {
                endGame('crewmates', 'All tasks completed!');
            }
        }

        function toggleRole() {
            const hidden = document.getElementById('role-hidden');
            const revealed = document.getElementById('role-revealed');
            const btn = document.getElementById('toggle-role-btn');

            if (hidden.classList.contains('hidden')) {
                hidden.classList.remove('hidden');
                revealed.classList.add('hidden');
                btn.textContent = 'Reveal Role';
            } else {
                hidden.classList.add('hidden');
                revealed.classList.remove('hidden');
                btn.textContent = 'Hide Role';
            }
        }

        function eliminatePlayer() {
            const player = gameState.players.find(p => p.name === gameState.currentPlayer);
            if (player) {
                player.isAlive = false;

                // Generate QR code for eliminated player
                const eliminatedMessage = `ELIMINATED: ${player.name} - Room: ${gameState.roomCode}`;
                const qrCodeImage = document.getElementById('eliminated-qr-code');
                const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=${encodeURIComponent(eliminatedMessage)}`;
                qrCodeImage.src = qrApiUrl;

                // Show eliminated modal
                document.getElementById('eliminated-modal').classList.remove('hidden');
            }
        }

        async function callMeeting() {
            if (gameState.meetingsUsed >= gameState.settings.meetingLimit) {
                alert('No emergency meetings remaining!');
                return;
            }

            // Set this player as the meeting caller
            gameState.meetingCaller = myPlayerName;
            console.log('Meeting called by:', myPlayerName);

            // Update database to trigger meeting for all players
            if (supabaseClient && currentGameId) {
                try {
                    const { error } = await supabaseClient
                        .from('games')
                        .update({
                            stage: 'meeting',
                            meetings_used: gameState.meetingsUsed,
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', currentGameId);

                    if (error) {
                        console.error('Error updating meeting state:', error);
                    } else {
                        console.log('Meeting state updated in database');
                    }
                } catch (err) {
                    console.error('Error calling meeting:', err);
                }
            }

            // Show the alert for this player
            document.getElementById('meeting-location-alert').textContent = gameState.settings.meetingRoom;
            document.getElementById('meeting-overlay').classList.remove('hidden');

            // Show meeting controls only for the caller
            document.getElementById('meeting-caller-controls').classList.remove('hidden');

            // Play alarm sound
            playAlarmSound();
        }

        function playAlarmSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            let count = 0;
            const interval = setInterval(() => {
                if (count >= 5) {
                    clearInterval(interval);
                    return;
                }
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.frequency.value = 800;
                oscillator.type = 'square';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
                count++;
            }, 400);
        }

        function acknowledgeMeeting() {
            document.getElementById('meeting-overlay').classList.add('hidden');
            document.getElementById('game-phase').classList.add('hidden');
            document.getElementById('meeting-phase').classList.remove('hidden');

            // Show appropriate meeting phase based on type
            if (gameState.meetingType === 'report') {
                document.getElementById('report-selection').classList.remove('hidden');
                // Populate eliminated players list
                const list = document.getElementById('eliminated-players-list');
                list.innerHTML = '';
                gameState.players.filter(p => !p.alive).forEach(player => {
                    const option = document.createElement('div');
                    option.className = 'vote-option';
                    option.innerHTML = `
                        <input type="checkbox" value="${player.name}">
                        <label>${player.name}</label>
                    `;
                    list.appendChild(option);
                });
            } else if (gameState.meetingType === 'emergency') {
                gameState.meetingsUsed++;
                document.getElementById('discussion-phase').classList.remove('hidden');
                startDiscussionTimer();

                // Update meetings used in database
                if (supabaseClient && currentGameId) {
                    updateGameInDB();
                }
            }
        }

        function selectMeetingType(type) {
            // Store the meeting type (both in gameState and settings for DB sync)
            gameState.meetingType = type;
            gameState.settings.meetingType = type;

            // Hide the caller controls on the overlay
            document.getElementById('meeting-caller-controls').classList.add('hidden');

            console.log('Meeting type selected:', type);

            // Update the database so all players know the meeting type
            if (supabaseClient && currentGameId) {
                updateGameInDB();
            }
        }

        function confirmReport() {
            document.getElementById('report-selection').classList.add('hidden');
            document.getElementById('discussion-phase').classList.remove('hidden');
            startDiscussionTimer();
        }

        function startDiscussionTimer() {
            let timeLeft = gameState.settings.meetingTimer;
            document.getElementById('discussion-timer').textContent = timeLeft;

            const interval = setInterval(() => {
                timeLeft--;
                document.getElementById('discussion-timer').textContent = timeLeft;

                if (timeLeft <= 0) {
                    clearInterval(interval);
                    startVoting();
                }
            }, 1000);
        }

        function startVoting() {
            document.getElementById('discussion-phase').classList.add('hidden');
            document.getElementById('voting-phase').classList.remove('hidden');

            // Populate vote options
            const voteOptions = document.getElementById('vote-options');
            voteOptions.innerHTML = '';

            gameState.players.filter(p => p.alive).forEach(player => {
                const option = document.createElement('div');
                option.className = 'vote-option';
                option.onclick = () => selectVote(player.name, option);
                option.innerHTML = `<strong>${player.name}</strong>`;
                voteOptions.appendChild(option);
            });

            // Add skip option
            const skipOption = document.createElement('div');
            skipOption.className = 'vote-option';
            skipOption.onclick = () => selectVote('skip', skipOption);
            skipOption.innerHTML = '<strong>Skip</strong>';
            voteOptions.appendChild(skipOption);

            // Start vote timer
            let timeLeft = gameState.settings.meetingTimer;
            document.getElementById('vote-timer').textContent = timeLeft;

            const interval = setInterval(() => {
                timeLeft--;
                document.getElementById('vote-timer').textContent = timeLeft;

                if (timeLeft <= 0) {
                    clearInterval(interval);
                    submitVote();
                }
            }, 1000);
        }

        let selectedVote = null;
        function selectVote(playerName, element) {
            document.querySelectorAll('.vote-option').forEach(opt => opt.classList.remove('selected'));
            element.classList.add('selected');
            selectedVote = playerName;
            document.getElementById('submit-vote-btn').disabled = false;
        }

        function submitVote() {
            document.getElementById('voting-phase').classList.add('hidden');
            document.getElementById('vote-results').classList.remove('hidden');

            // Placeholder vote results
            document.getElementById('results-display').innerHTML = `
                <div class="vote-results">
                    <div>Player 1: <strong>3 votes</strong></div>
                    <div class="vote-bar"><div class="vote-bar-fill" style="width: 60%"></div></div>
                </div>
                <div class="vote-results">
                    <div>Player 2: <strong>2 votes</strong></div>
                    <div class="vote-bar"><div class="vote-bar-fill" style="width: 40%"></div></div>
                </div>
            `;

            document.getElementById('ejected-player-text').textContent =
                'Player 1 was ejected. They were an Imposter.';
        }

        function resumeGame() {
            document.getElementById('meeting-phase').classList.add('hidden');
            document.getElementById('game-phase').classList.remove('hidden');
        }

        function closeEliminatedModal() {
            document.getElementById('eliminated-modal').classList.add('hidden');
        }

        function endGame(winner, message) {
            console.log('Game ending - Winner:', winner, 'Message:', message);

            // Update game state
            gameState.gameEnded = true;
            gameState.winner = winner;
            gameState.stage = 'ended';

            // Update database
            if (supabaseClient && currentGameId) {
                updateGameInDB();
            }

            // Hide game phase
            document.getElementById('game-phase').classList.add('hidden');
            document.getElementById('meeting-phase').classList.add('hidden');

            // Show game end screen
            document.getElementById('game-end').classList.remove('hidden');

            // Determine if this player won or lost
            const player = gameState.players.find(p => p.name === myPlayerName);
            const playerRole = player ? player.role : null;

            // Crewmates win if winner is 'crewmates', imposters win if winner is 'imposters'
            const didPlayerWin = (playerRole === 'crewmate' && winner === 'crewmates') ||
                                 (playerRole === 'imposter' && winner === 'imposters');

            // Show appropriate screen
            if (didPlayerWin) {
                document.getElementById('victory-screen').classList.remove('hidden');
                document.getElementById('defeat-screen').classList.add('hidden');
                document.getElementById('meeting-location-victory').textContent = gameState.settings.meetingRoom;
            } else {
                document.getElementById('victory-screen').classList.add('hidden');
                document.getElementById('defeat-screen').classList.remove('hidden');
                document.getElementById('meeting-location-defeat').textContent = gameState.settings.meetingRoom;
            }

            // Populate game summary
            populateGameSummary();

            // Show host controls if this player is the host
            if (isHost()) {
                document.getElementById('host-game-controls').classList.remove('hidden');
            }
        }

        function populateGameSummary() {
            const summaryDiv = document.getElementById('game-summary');
            const winningTeam = document.getElementById('winning-team');

            // Set winning team text
            if (gameState.winner === 'crewmates') {
                winningTeam.textContent = 'Crewmates Win!';
                winningTeam.style.color = '#4CAF50';
            } else if (gameState.winner === 'imposters') {
                winningTeam.textContent = 'Imposters Win!';
                winningTeam.style.color = '#ff3838';
            }

            // Build player summary HTML
            summaryDiv.innerHTML = '';
            gameState.players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.style.cssText = 'background: rgba(255,255,255,0.05); padding: 15px; margin-bottom: 15px; border-radius: 8px; border-left: 4px solid ' + (player.role === 'imposter' ? '#ff3838' : '#4CAF50');

                const roleText = player.role.charAt(0).toUpperCase() + player.role.slice(1);
                const statusText = player.alive ? 'Alive' : 'Eliminated';
                const statusColor = player.alive ? '#4CAF50' : '#ff3838';

                // Build tasks list
                let tasksHTML = '<div style="margin-top: 10px;">';
                if (player.tasks && player.tasks.length > 0) {
                    player.tasks.forEach((taskObj, index) => {
                        const completed = index < (player.tasksCompleted || 0);
                        const checkmark = completed ? '‚úì' : '‚óã';
                        const color = completed ? '#4CAF50' : '#a0a0a0';
                        tasksHTML += `<div style="color: ${color}; font-size: 0.9rem; margin: 3px 0;">${checkmark} ${taskObj.task} (${taskObj.room})</div>`;
                    });
                } else {
                    tasksHTML += '<div style="color: #a0a0a0; font-size: 0.9rem;">No tasks</div>';
                }
                tasksHTML += '</div>';

                playerCard.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong style="font-size: 1.1rem;">${player.name}</strong>
                        <div style="text-align: right;">
                            <span style="background: ${player.role === 'imposter' ? '#ff3838' : '#4CAF50'}; padding: 3px 10px; border-radius: 12px; font-size: 0.85rem; margin-right: 8px;">${roleText}</span>
                            <span style="color: ${statusColor}; font-size: 0.9rem;">${statusText}</span>
                        </div>
                    </div>
                    <div style="color: #a0a0a0; font-size: 0.9rem; margin-bottom: 5px;">
                        Tasks: ${player.tasksCompleted || 0}/${player.tasks ? player.tasks.length : 0} completed
                    </div>
                    ${tasksHTML}
                `;

                summaryDiv.appendChild(playerCard);
            });
        }

        function closeVictoryScreen() {
            document.getElementById('victory-screen').classList.add('hidden');
        }

        function closeDefeatScreen() {
            document.getElementById('defeat-screen').classList.add('hidden');
        }

        async function newGameSameSettings() {
            if (!isHost()) return;

            console.log('Host starting new game with same settings - going to setup');

            // Reset game state but keep settings
            gameState.players = [];
            gameState.meetingsUsed = 0;
            gameState.gameEnded = false;
            gameState.stage = 'setup';  // Go to setup, not waiting
            gameState.winner = null;
            gameState.meetingCaller = null;
            gameState.meetingType = null;
            gameState.isNewGameAfterPrevious = true;  // Flag to send invitations later

            // Update database
            if (supabaseClient && currentGameId) {
                await updateGameInDB();
            }

            // Clear all game end UI
            document.getElementById('victory-screen').classList.add('hidden');
            document.getElementById('defeat-screen').classList.add('hidden');
            document.getElementById('game-summary').innerHTML = '';
            document.getElementById('winning-team').textContent = '';
            document.getElementById('host-game-controls').classList.add('hidden');

            // Hide game end, show setup
            document.getElementById('game-end').classList.add('hidden');
            document.getElementById('setup-phase').classList.remove('hidden');
        }

        async function newGameNewSettings() {
            if (!isHost()) return;

            console.log('Host starting new game with new settings - going to setup');

            // Reset game state
            gameState.players = [];
            gameState.meetingsUsed = 0;
            gameState.gameEnded = false;
            gameState.stage = 'setup';
            gameState.winner = null;
            gameState.meetingCaller = null;
            gameState.meetingType = null;
            gameState.isNewGameAfterPrevious = true;  // Flag to send invitations later

            // Update database
            if (supabaseClient && currentGameId) {
                await updateGameInDB();
            }

            // Clear all game end UI
            document.getElementById('victory-screen').classList.add('hidden');
            document.getElementById('defeat-screen').classList.add('hidden');
            document.getElementById('game-summary').innerHTML = '';
            document.getElementById('winning-team').textContent = '';
            document.getElementById('host-game-controls').classList.add('hidden');

            // Hide game end, show setup
            document.getElementById('game-end').classList.add('hidden');
            document.getElementById('setup-phase').classList.remove('hidden');
        }

        function acceptNewGameInvitation() {
            console.log('=== acceptNewGameInvitation called ===');
            console.log('myPlayerName:', myPlayerName);

            // Hide the invitation modal and join button
            document.getElementById('new-game-invitation').classList.add('hidden');
            document.getElementById('join-next-game-section').classList.add('hidden');
            console.log('Invitation modal hidden');

            // Clear all game end UI
            document.getElementById('victory-screen').classList.add('hidden');
            document.getElementById('defeat-screen').classList.add('hidden');
            document.getElementById('game-summary').innerHTML = '';
            document.getElementById('winning-team').textContent = '';
            document.getElementById('game-end').classList.add('hidden');
            console.log('Game end UI cleared');

            // Show name confirmation modal
            console.log('Calling showNameConfirmation...');
            showNameConfirmation();
        }

        function showNameConfirmation() {
            console.log('=== showNameConfirmation called ===');
            console.log('myPlayerName:', myPlayerName);

            // Set the previous name display
            document.getElementById('previous-name-display').textContent = myPlayerName || '';
            console.log('Set previous name display');

            // Reset the edit section
            document.getElementById('name-edit-section').classList.add('hidden');
            document.getElementById('name-edit-input').value = myPlayerName || '';
            document.getElementById('confirm-name-btn').classList.remove('hidden');
            document.getElementById('edit-name-btn').classList.remove('hidden');
            console.log('Reset edit section and buttons');

            // Show the modal
            document.getElementById('name-confirmation-modal').classList.remove('hidden');
            console.log('Name confirmation modal shown');
        }

        function editPlayerName() {
            console.log('Player wants to edit name');

            // Show the edit input section
            document.getElementById('name-edit-section').classList.remove('hidden');
            document.getElementById('name-edit-input').focus();

            // Hide the confirm and edit buttons, only show the input
            document.getElementById('confirm-name-btn').textContent = 'Save Name';
            document.getElementById('edit-name-btn').classList.add('hidden');
        }

        async function confirmPlayerName() {
            console.log('=== confirmPlayerName called ===');

            // Check if we're in edit mode
            const editSection = document.getElementById('name-edit-section');
            let nameToUse = myPlayerName;

            console.log('Edit mode:', !editSection.classList.contains('hidden'));

            if (!editSection.classList.contains('hidden')) {
                // In edit mode - get the new name
                const newName = document.getElementById('name-edit-input').value.trim();
                if (!newName) {
                    alert('Please enter a name');
                    return;
                }
                nameToUse = newName;
                myPlayerName = newName; // Update the stored name
                console.log('Name changed to:', nameToUse);
            }

            console.log('Player confirmed name:', nameToUse);

            // Hide the modal
            document.getElementById('name-confirmation-modal').classList.add('hidden');
            console.log('Name confirmation modal hidden');

            // Show waiting room
            document.getElementById('waiting-room').classList.remove('hidden');
            console.log('Waiting room shown');

            // Add player to the game
            if (supabaseClient && currentGameId) {
                console.log('Adding player to game...');
                await addPlayerToGame(nameToUse);
                console.log('Player added');
            }
        }

        function leaveGame() {
            console.log('Player chose to leave game');

            // Hide the modal
            document.getElementById('name-confirmation-modal').classList.add('hidden');

            // Return to menu
            returnToMenu();
        }

        function declineNewGameInvitation(response) {
            console.log('Player declined new game invitation:', response);

            // Hide the invitation modal
            document.getElementById('new-game-invitation').classList.add('hidden');

            if (response === 'later') {
                // Show "Join Next Game" button
                document.getElementById('join-next-game-section').classList.remove('hidden');
            }
            // If response is 'no', just stay in the current screen
        }

        function endSession() {
            if (confirm('Are you sure you want to end this session?')) {
                location.reload();
            }
        }

        // Initialize on load
        window.onload = async () => {
            initializeRoomsAndTasks();
            updateMeetingRoomDropdown();
            setupUniqueRadioListeners();

            // Check if joining existing game via URL parameter
            const urlParams = new URLSearchParams(window.location.search);
            const roomCode = urlParams.get('room');

            if (roomCode && supabaseClient) {
                // Hide menu, try to join existing game
                document.getElementById('main-menu').classList.add('hidden');
                document.getElementById('setup-phase').classList.add('hidden');

                const gameData = await joinGameFromDB(roomCode);

                if (gameData) {
                    // Successfully joined game
                    document.getElementById('room-code').textContent = roomCode;

                    // Update displays
                    document.getElementById('min-players-display').textContent = gameState.settings.minPlayers;
                    document.getElementById('max-players-display').textContent = gameState.settings.maxPlayers;
                    document.getElementById('imposter-count-display').textContent = gameState.settings.imposterCount;

                    // Show appropriate stage
                    if (gameState.stage === 'waiting') {
                        document.getElementById('waiting-room').classList.remove('hidden');
                        generateQRCode();
                        updateJoinSection();
                        updateLobby();
                    } else if (gameState.stage === 'playing') {
                        document.getElementById('game-phase').classList.remove('hidden');
                        // Don't call displayGameplay() yet - player needs to join first
                    }
                } else {
                    alert(`Game with room code "${roomCode}" not found.`);
                    // Show menu since game wasn't found
                    document.getElementById('main-menu').classList.remove('hidden');
                }
            } else {
                // No room code in URL - show main menu
                document.getElementById('setup-phase').classList.add('hidden');
                document.getElementById('main-menu').classList.remove('hidden');
            }
        };
    </script>
</body>
</html>
